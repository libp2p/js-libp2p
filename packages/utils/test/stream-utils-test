/* eslint-env mocha */

import { Buffer } from 'buffer'
import { expect } from 'aegir/chai'
import delay from 'delay'
import { Uint8ArrayList } from 'uint8arraylist'
import { concat as uint8ArrayConcat } from 'uint8arrays/concat'
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'
import { byteStream } from '../src/stream-utils.js'
import type { ByteStream } from '../src/stream-utils.js'
import type { MessageStream } from '@libp2p/interface'
import { streamPair } from '../src/stream-pair.ts'
import { raceEvent } from 'race-event'

interface Test<T> {
  from(str: string): T
  alloc(length: number, fill?: number): T
  allocUnsafe(length: number): T
  concat(arrs: T[], length?: number): T
  writeInt32BE(buf: T, value: number, offset: number): void
}

const tests: Record<string, Test<any>> = {
  Buffer: {
    from: (str: string) => Buffer.from(str),
    alloc: (length: number, fill = 0) => Buffer.alloc(length, fill),
    allocUnsafe: (length: number) => Buffer.allocUnsafe(length),
    concat: (arrs: Buffer[], length?: number) => Buffer.concat(arrs, length),
    writeInt32BE: (buf: Buffer, value: number, offset: number) => buf.writeInt32BE(value, offset)
  },
  Uint8Array: {
    from: (str: string) => uint8ArrayFromString(str),
    alloc: (length: number, fill = 0) => new Uint8Array(length).fill(fill),
    allocUnsafe: (length: number) => new Uint8Array(length),
    concat: (arrs: Buffer[], length?: number) => uint8ArrayConcat(arrs, length),
    writeInt32BE: (buf: Buffer, value: number, offset: number) => {
      new DataView(buf.buffer, buf.byteOffset, buf.byteLength).setInt32(offset, value, false)
    }
  },
  Uint8ArrayList: {
    from: (str: string) => new Uint8ArrayList(uint8ArrayFromString(str)),
    alloc: (length: number, fill = 0) => new Uint8ArrayList(new Uint8Array(length).fill(fill)),
    allocUnsafe: (length: number) => new Uint8ArrayList(new Uint8Array(length)),
    concat: (arrs: Uint8ArrayList[], length?: number) => new Uint8ArrayList(...arrs),
    writeInt32BE: (buf: Uint8ArrayList, value: number, offset: number) => {
      const data = new Uint8Array(4)
      new DataView(data.buffer, data.byteOffset, data.byteLength).setInt32(offset, value, false)
      buf.write(data, offset)
    }
  }
}

describe('byte-stream', () => {
  it('returns null if underlying stream is empty', async () => {
    const pair = await streamPair()
    const b = byteStream(pair[0])
    const res = b.read()

    pair[1].close()

    await raceEvent(pair[1], 'close')
    await expect(res).to.eventually.be.null()
  })

  it('throws EOF if underlying stream is empty and bytes are specified', async () => {
    const pair = await streamPair()
    const b = byteStream(pair[0])
    const res = b.read({
      bytes: 10
    })

    pair[1].close()

    await raceEvent(pair[1], 'close')

    await expect(res).to.eventually.be.rejected
      .with.property('name', 'UnexpectedEOFError')
  })
})

Object.keys(tests).forEach(key => {
  const test = tests[key]

  describe(`byte-stream ${key}`, () => {
    let a: ByteStream
    let b: ByteStream
    let remote: MessageStream

    beforeEach(() => {
      const pair = await streamPair()
      b = byteStream(pair[0])
      a = byteStream(pair[1])
      remote = pair[1]
    })

    it('unwraps underlying stream', () => {
      const w = byteStream(remote)

      expect(w.unwrap()).to.equal(remote)
    })

    it('whole', async () => {
      const data = test.from('ww')

      void a.write(data)
      const res = await b.read({ bytes: 2 })

      expect(res.subarray()).to.equalBytes(data.subarray())
    })

    it('split', async () => {
      const data = test.from('ww')

      const r = test.from('w')
      void a.write(data)

      const r1 = await b.read({ bytes: 1 })
      const r2 = await b.read({ bytes: 1 })

      expect(r.subarray()).to.equalBytes(r1.subarray())
      expect(r.subarray()).to.equalBytes(r2.subarray())
    })
  })
})
